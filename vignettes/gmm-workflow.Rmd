---
title: "borealis for GMM"
author: "Dave Angelini"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{borealis for GMM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

![](https://live.staticflickr.com/65535/49112559173_96cfbd9d2a_w_d.jpg)

Morphometry is a the study of shape and its variations.
It allows comparisons of shape between different groups. 
This is a subtle way to analyze phenotypes. Shape analysis typically also includes a consideration of size, since shape typically varies with size (allometry).
Therefore morphometrics can be a good way to examine growth and scaling.

A typical workflow for geometric morphometrics (GMM) looks this this:

1. **Image** specimens - For 2D morphomeytrics, this typically involves photography
2. **Digitize** anatomical position of landmarks
3. **Data curation** - Are the specimens all roughly facing the same direction? Are there jointed structures whose position may interfer with downstream steps?
4. **Generalized Procrustes Analysis (GPA)** aligns specimens to one another, minimizing variance due to relative position, rotation and size. Size is typicall retained as a separate variable that can be included in the analysis later. 
5. **Data curation** - Are there obvious outliers that should be removed?
6. **Ordination** by tangent-space projection (similar to PCA) highlights differences among individuals and groups
7. **Modularity tests**
8. **Disparity comparisons** among groups
9. **Model** influences on size and shape  (e.g. due to allometric scaling, evolutionary relationships, environmental factors)

GMM and morphometry in general is a rich discipline where people have developed a number of excellent analytical tools.
However, some of these can be difficult to use.
The main goal of the `borealis` package is to provide R users with a set of relatively simple tools to perform GMM analysis (and some other biology related activities). 

Importantly, GMM typically involves a number of data processing steps. 
The `borealis` package embraces the concept of [data provenance](https://en.wikipedia.org/wiki/Data_lineage#Data_provenance). Each time a dataset is modified, functions in the package add (or add to) a list element recording important details about the execution and results of that step. This information can then be written to a [markdown](https://www.markdownguide.org/getting-started/) file as a report of the data's history and handling throughout the workflow. 

`borealis` also includes functions that produce publication-ready figures with minimal user effort.

## Installing the R package

If you've previously loaded the package, it is helpful to "unload" it before installing a newer version.

```{r eval=FALSE, include=TRUE}
detach("package:borealis", unload = TRUE)
```

If you've never installed a package from GitHib before, it may be necessary for you to install the package `devtools`.

```{r eval=FALSE, include=TRUE}
install.packages("devtools")

devtools::install_github("aphanotus/borealis")
```

Once that's all sorted out, you can load the package 

```{r}
library(borealis)
```

## Managing raw coordinate data

For landmark-based geometric morphometrics, the first step is to "digitize" coordinate positions in digital images of each specimen.
[ImageJ](https://imagej.net/) provides the easiest way to do this.

### Digitizing specimens in ImageJ

Before you begin, think carefully about the landmarks you should use to represent the shape
of the the structure you're interested in. Areas with a greater density of landmarks will
capture more shape variation among specimens. However, you don't necessarily need dozens of
landmarks. Important insights can still be obtained from a simple set of landmarks. 

Often, it's helpful to try a number of different landmark configurations on a small group of
diverse specimens to see how well they perform. Importantly, you want landmarks that are present in all specimens and that can be placed with good confidence by everyone involved in the digitizing effort. 
I suggest writing up a good map of all the landmarks before proceeding with the digitization.

![](https://i.imgur.com/QDTUaFK.jpg)

1. **Open a specimen image** in ImageJ. Be sure metadatam, such as sex, species, etc., are recorded somewhere. Be sure a scale bar is present in the image. If needed flip or rotate images so they are relatively consistent. Omit specimens with missing anatomical features.
2. Use the **line tool** to measure the scale and trace any linear anatomical features. 
3. Use the **multi-point tool** to place landmarks. Place each landmark, in order. Consult your anatomy guide until youâ€™re familiar with everything!
4. **Press `[cmnd]` `M`** to record data in a table in ImageJ.
5. **Select and Copy** the measured data from ImageJ.
6. **Paste** the values into Google Sheets (or Excel). Be sure to keep the data in a consistent format.

The first row of the spread sheet should provide column names. 
Enter the X and Y values under columns named "x" and "y". 
There must be a column giving specimen IDs, such as "specimen.ID", and one for scale.
Add other columns to record relevant metadata. 
The ID names, scale and other metadata, should be entered on the row for the first landmark of the specimen. 
Any linear measurements accompanying the specimen should be treated as metadata.
Coordinate positions and metadata for each specimen should appear in a consequtive block of rows. In other words, in you have 3 landmarks: row 1 is the header, rows 2-4 are the data for specimen 1, rows 5-7 are the data for specimen 2, etc. 
This spreadsheet format is convenient, since it allows rapid copy-and-paste of data from ImageJ with minimal formating. It will also fasciliate converting the coordinate positions and encoding the metadata into the `tps` format in the next step.

### Convert raw landmark coordinates into the `tps` file format

The `tps` ("thin-plate spline") file format is one of the most commonly used formats among different GMM software ([Rohlf 2015](https://doi.org/10.4404/hystrix-26.1-11264)). 
Creating a large `tps` file manually can be difficult. A stray space or tab can prevent downstream software from handling it properly, and those issues can be very hard to tackle down.
For that reason, `borealis` includes a simple function `create.tps` to convert spreadsheet data, as described above, into a `tps` file. It will also begin recording data provenance and embed metadata for each specimen.

The scale value can also be inverted, by setting `invert.scale = TRUE`. The default for downstream functions is to apply scale values by multiplication. Typically this is appropriate when scale is recorded as unit distance (e.g. mm) per pixel. However, if scale is recorded in pixels per unit distance (e.g. pixels/mm) it will be appropriate to first invert the scaling factor before importing coordinate data.

```{r eval=FALSE, include=TRUE}
create.tps(
  input.filename = "wings.csv",
  output.filename = "wings.tps",
  id.factors = c('species','caste','digitizer'),
  include.scale = TRUE,
  invert.scale = TRUE)
```

The file that's created will looks like this.

```
# ## TPS file creation 
# 
# Created by user `drangeli` with `borealis::create.tps` on Monday, 22 June 2020, 15:11:47
# 
# Input file:  ~/Documents/3.research/2.Bombus.mouthparts/Bombus wing GMM/Bombus Wings - forewings.csv 
# 
# The dataset is 20 x 2 x 99 (*p* landmarks x *k* dimensions x *n* specimens)
# 
# Metadata are encoded in specimen ID lines from the following factors:
# - species
# - caste
# - digitizer
# 
# Metadata separator: __
# 
# **Scale** included and **inverted** from the original dataset.
# 

LM=20
1942 354.667
1650 336
1690 361.333
1747.333 377.333
1851.333 400
1867.333 440.667
1832.667 503.333
1819.333 507.333
1743.333 479.333
1674 486
1608.667 419.333
1488.667 387.333
1231.333 467.333
1471.333 518
1478 584.667
1478 594
1724.667 590
1447.333 650
1192.667 539.333
1479.333 679
ID=DRA190718-001__vag__W__JL
SCALE=0.00702814773166532
```

## Import `tps` data into R

To start a workflow, you will typically begin from a `tps` file. 
The function `read.tps` can do several early steps, but let's start by looking at a simple usage.

```{r eval=FALSE, include=TRUE}
shapes <- read.tps("wings.tps")
```

This creates the object `shapes`. 
It is what R knows as a `list`, a type of data object that can include many different elements, all accessible together. 
You ccan reveal the components of the list using the `names` function.

```{r eval=FALSE, include=TRUE}
names(shapes) 
```

```
[1] "coords"          "landmark.number" "specimen.number" "scaled"
[5] "metadata"        "provenance"     
```

The `coords` element is a 3-dimensional array of the coordinated positions. `landmark.number` and `specimen.number` are obvious. 
The element `scaled` is a logical value stating whether the coordinates
have already been scaled. If this is true (it is here), then you should
avoid applying any scale a second time! 
The element `metadata` is a data frame with metadata. 
Each specimen is a row in this table, and ID names are the same in the `metadata` row and `coords` element. Specimens are also in the same order in those two elements. Finally the `provenance` element contains data provenance, which will be added to as the workflow continues.

```{r eval=FALSE, include=TRUE}
names(shapes$provenance)
```

```
[1] "create.tps" "read.tps"
```

You can look at the contents of the data provance elements this way. 

```{r eval=FALSE, include=TRUE}
cat(unlist(shapes$provenance$read.tps))
```

```
## TPS data import

Performed by user `drangeli` with `borealis::read.tps` on Tuesday, 23 June 2020, 17:40:40

Metadata were extracted from specimen ID lines for the following factors:
- specimen.id
- species
- caste
- digitizer
```

### View the shape data

The `borealis` package has a simple function for viewing the relative positions of landmarks. 
The function is designed to user-friendly. 
It will automatically detect whether you're giving it coordinates for one specimen, a 3D array with coordinates for multiple specimens, or 
a `list` object with such an array as one component. 
So all of the commands below will produce the same plot.

```{r eval=FALSE, include=TRUE}
landmark.plot(shapes$coords[,,1])
landmark.plot(shapes$coords)
landmark.plot(shapes)
```

![](https://i.imgur.com/SQpXxcG.jpg)

The function defaults to looking at the first specimen in the array, but you can also specify others.

```{r eval=FALSE, include=TRUE}
landmark.plot(shapes, specimen.number = 2)
```

### Viewing shapes with landmark connections

Often it's convenient to look at shape data with the landmarks connected in a way that reflects their biological meaning. 
You can ask `landmark.plot` to include these connections if you first define them as a matrix. In the example below, each connections is indicated by adjacent landmark numbers.

```{r eval=FALSE, include=TRUE}
fw.links <- matrix(c(1,2, 1,5, 5,4, 4,3, 3,2, 5,6, 6,7, 7,8, 8,9, 9,4, 3,11, 11,12, 11,10, 9,10, 10,14, 14,15, 15,16, 16,18, 18,20, 16,17, 17,8, 12,13, 13,19, 14,13, 18,19, 2,12),
                   ncol = 2, byrow = TRUE)

landmark.plot(shapes, links = fw.links)
```

![](https://i.imgur.com/KYVXHzN.jpg)

### Bombus forewing data

The data as they exist in our `shape` object right now are included in the `borealis` package. You could choose to start the tutorial at this point using the following command.

```{r eval=FALSE, include=TRUE}
shapes <- data("Bombus.forewings", package = "borealis")
```

## Re-orient specimens

Occatinoally, a few specimens in a dataset are entered upside-down or "reflected" relative to the others. Or perhaps ImageJ recorded XY coordinates with the origin at the lower left, instead of the upper left. In these instances, it's helpful to go through all the specimens and "orient" them to have certain landmarks up or to the left.

The function `orient` will accomplish this, and update the data provenance to list all the reorientiations that are made.

```{r eval=FALSE, include=TRUE}
shapes <- orient(shapes, topLM = 2, leftLM = 1, links = fw.links )
```

![](https://i.imgur.com/EZdEwYv.jpg)

To save time, the re-orientation step can be included in the initial `read.tps` statement.

```{r eval=FALSE, include=TRUE}
shapes <- read.tps("wings.tps", 
                   orient.specimens = TRUE,
                   topLM = 2, leftLM = 1, links = fw.links)
```

## Joint alignment

Joints can introduce nuisance variation in landmark-based geometric morphometrics. The `borealis` function `align.jopint` rotates a subset of landmarks about a pivot point. 
You need to designate a reference specimen, and other specimens will be aligned so that the angle of the main set of landmarks and the substructure always have the same angle. 

This step should be run before Procrustes alignment, and it is robust to differences in the relative position, orientation and size of specimens.

However, it's not always necessary to do this. If the structure you're analyzing isn't jointed, then there's no need for it. 

For this vignette, I'm going to stretch the utility of our example dataset. The shape data we've been working with are from bumblebee wings. They are not jointed. However, for the sake of the example, let's imagine we have reason to suspect that landmarks 13 and 19, hinge relative to the rest of the wing's landmarks. The specimens we've been looking at (number 1, by default) will be used as the specimen to define the reference angle.

```{r eval=FALSE, include=TRUE}
shapes <- align.joint(shapes, 
                      substructure.LMs = c(13,19),
                      pivot.LM = 14,
                      reference.specimen = 1,
                      include.plot = TRUE)
```

![](https://i.imgur.com/qagHjnu.jpg)

By default, the function will not show a plot. However, if (as in this example) you include the arguyement `include.plot = TRUE`, then each specimen is plotted as above. The gray dots show the location of the landmarks in the main structure. The red dot is the pivot point. The open red circles are the old positions of landmarks in the substructure that's been aligned; the black dots are their new locations.

## Procrustes alignment

[Generalized Procrustes analysis](https://en.wikipedia.org/wiki/Procrustes_analysis#Generalized_Procrustes_analysis_(GPA)) minimizes the variance in distances between the landmarks of different specimens. It does this by translating, rotating and re-sizing each specimen's coordinates, but not changing their relative distances to one another. 
In this way, GPA makes shapes comparable and removes trivial issues introduced by their original imaging. 
GPA also retains size information as [centroid size](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4896994/#:~:text=Centroid%20size%20is%20the%20measure,y%20coordinates%20of%20all%20landmarks).). 

```{r eval=FALSE, include=TRUE}
wing.gpa <- procrustes.alignment(shapes)
```

![](https://i.imgur.com/AXVWXFV.jpg)

What's happening behind the scenes is that `borealis` relies on the function `gpagen` in the R package `geomorph`. The output of the `procrustes.alignment` contains the same list elements produced by `geomorph::gpagen`. However it also retains any list elements from the input and add to the data provenance element.

### Outlier detection

After inital GPA, it's typically important to remove any obvious outliers. These may be specimens where coordinate positions were recorded incorrectly. 
There presences in the dataset can skew signals that are actually of interest. 

`procrustes.alignment` fasciliates interactive outlier detection and removal. Just include the arguement `outlier.analysis = TRUE`. The function will run `geomorph::plotOutliers`, then display
warp grids for the most extreme shapes and prompt the user to remove some number of them. This can be done iteratively.

```{r eval=FALSE, include=TRUE}
wing.gpa <- procrustes.alignment(shapes, outlier.analysis = TRUE)
```

![](https://i.imgur.com/VwKtdq3.jpg)

![](https://i.imgur.com/DHZkZZ7.jpg)

In this case, removing the two most extreme outliers looks prudent.

### Convert data into a geomorph data frame

The `geomorph` package ([Adams et al. 2020](https://cran.r-project.org/package=geomorph)) provides a powerful set of tools for GMM analysis. 
Many functions require shape, size and metadata to be in a data structure called a `geomorph.data.frame`. 
In order to retain data provenance and other elements of our data object, we can use the function `listed.gdf` to convert the `gpagen` and `metadata` elements of our list into a `geomorph.data.frame` while still keeping it within a list with the other elements.

```{r eval=FALSE, include=TRUE}
wing.gpa <- listed.gdf(wing.gpa)
```

We can then take a look at the new data structure.

```{r eval=FALSE, include=TRUE}
names(wing.gpa)
```

```
[1] "gdf"             "landmark.number" "specimen.number" "scaled"          "provenance"     
```

```{r eval=FALSE, include=TRUE}
names(wing.gpa$gdf)
```

```
[1] "specimen.id" "species"     "caste"       "digitizer"   "coords"      "Csize"      
```

```{r eval=FALSE, include=TRUE}
names(wing.gpa$provenance)
```

```
[1] "create.tps"           "read.tps"             "reorientation"        "align.joint"         
[5] "procrustes.alignment" "listed.gdf"          
```

The data structure is actually described in the provenance report for this step.

```{r eval=FALSE, include=TRUE}
cat(wing.gpa$provenance$listed.gdf)
```

```
## Geomorph data frame conversion

Performed by user `drangeli` with `borealis::listed.gdf` on Wednesday, 24 June 2020, 00:12:10

Current data structure:
- gdf
  - specimen.id
  - species
  - caste
  - digitizer
  - coords
  - Csize
- landmark.number
- specimen.number
- scaled
- provenance
```

## Ordination (PCA)

To visualize variance in shapes, we perform a form of [ordination](https://en.wikipedia.org/wiki/Ordination_(statistics)) known as [Kendall's tangent space projection](https://books.google.com/books?id=5DLZ4lALRTEC&pg=PA98&lpg=PA98&dq=kendall%27s+tangent+space+projection&source=bl&ots=rUkeUb03p4&sig=ACfU3U1VPanhRZUBdXtZm_4_dw5RBUGBTA&hl=en&sa=X&ved=2ahUKEwj9qdLdzJnqAhUdknIEHXO2DV8Q6AEwEHoECAoQAQ#v=onepage&q=kendall's%20tangent%20space%20projection&f=false). Mathematically, this is similar to [principal component analysis (PCA)](https://en.wikipedia.org/wiki/Principal_component_analysis). 

```{r eval=FALSE, include=TRUE}
wing.pca <- gm.prcomp(wing.gpa$gdf$coords)
```

To examine the eigenvalues and proportionl variance for each dimension in the analysis, run `summary`.

```{r eval=FALSE, include=TRUE}
summary(wing.pca)
```

```
Ordination type: Principal Component Analysis 
Centering and projection: OLS 
Number of observations 97 
Number of vectors 40 

Importance of Components:
                              Comp1        Comp2        Comp3        Comp4        Comp5
Eigenvalues            0.0002302972 0.0001681885 8.952373e-05 6.013661e-05 4.486361e-05
Proportion of Variance 0.2694561165 0.1967867258 1.047460e-01 7.036203e-02 5.249206e-02
Cumulative Proportion  0.2694561165 0.4662428423 5.709889e-01 6.413509e-01 6.938430e-01
```

While it can be useful to know how to work with the raw output from PCA analysis, often people are most interested in plotting the first two PC axes. PCA is particularly helpful for understanding differences in shapes among groups. And group membership can be mapped onto the shape-shape plot.

```{r eval=FALSE, include=TRUE}
plot(wing.pca, col = as.factor(wing.gpa$gdf$species))
```

![](https://i.imgur.com/bduPIp4.jpg)

This is okay, but it's not very pretty. The `borealis` package has a function to plot these values using `ggplot2` with colorblind-friendly palletes.

```{r eval=FALSE, include=TRUE}
ggGMMplot(wing.pca, group = wing.gpa$gdf$species, 
          group.title = 'species', 
          convex.hulls = TRUE, include.legend = TRUE)
```

![](https://i.imgur.com/uNanxMW.jpg)

It can also be helpful to examine a version of the morphospace plot that provides example shapes. This is possible too, using `ggGMMplot` with the arguement `backtransform.examples = TRUE`. 
It then requires a reference shape, which can be supplied with the `geomorph` function `mshape`, which calculates a mean shape. 
Since shape differences can be subtle, it can be helpful to apply a magnificatino factort using the `bt.shape.mag` arguement.

```{r eval=FALSE, include=TRUE}
ggGMMplot(wing.pca, group = wing.gpa$gdf$species, 
          group.title = 'species', convex.hulls = TRUE,
          backtransform.examples = TRUE,
          ref.shape = mshape(wing.gpa$gdf$coords),
          shape.method = "TPS",
          bt.shape.mag = 3,
          bt.links = fw.links)
```

![](https://i.imgur.com/EYGK3aQ.jpg)

**Coming soon**
- Phylogenetic PCA
- Model testing
  - Allometry tests
- Allometry-corrected PCA
- Disparity comparisons
- Modularity testing


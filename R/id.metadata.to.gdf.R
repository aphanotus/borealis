#' Extract metadata from the specimen IDs in an array of coordinate shape data
#'
#' The function assumes that the ID names have been used to
#' embed metadata. This can be done if a \code{tps} file is generated using
#' \code{\link{create.tps}}. Check the header information or \code{ID} lines to determine
#' the metadata seperator. By default \code{seperator = "__"}, the same as that used
#' by \code{\link{create.tps}}.
#'
#' The input is ideally an object produced by \code{\link[geomorph]{gpagen}}, in which case centroid size
#' (if present) will be added to the \code{geomorph.data.frame}.
#'
#' The input data object can be a 3-dimensional array with ID names in the third element of \code{dimnames},
#' the output of \code{\link[geomorph]{gpagen}}, or a list generated by \code{\link{read.tps}}
#' (containing a \code{coords} element). It is also possible to pass in a character vector of ID names,
#' for example, directly from \code{dimnames}. The function will also recognize PCA objects of the class
#' \code{prcomp} or \code{gm.prcomp}. However, if PCA or character input is given, then the output will not
#' include shape coordinates. If the output includes shape data, then it is returned as
#' class \code{geomorph.data.frame}. Otherwise, the output is a regular \code{data.frame}.
#'
#' @source   Dave Angelini \email{david.r.angelini@@gmail.com} [aut, cre]
#'
#' @references  Geomorph: Software for geometric morphometric analyses.
#' R package version 3.2.1. D.C. Adams and M.L. Collyer and A. Kaliontzopoulou. 2020.
#' (\href{https://cran.r-project.org/package=geomorph}{Link})
#' @references  Rohlf, FJ. 2015. The tps series of software. \emph{Hystrix} 26, 9â€“12.
#' (\href{https://doi.org/10.4404/hystrix-26.1-11264}{Link})
#'
#' @param A 3-dimensional array containing XY shape corrdinates for multiple specimens, or a character vector of specimen IDs.
#' @param id.factors Metadata column names to be encoded in the specimen IDs.
#' @param seperator A character string to separate the terms used in the ID line.
#' @param size.data An optional vector with size data for each specimen. If input is pass as an object of class
#'     \code{gpagen} containing \code{Csize}, it will automatically be included in the output \code{geomorph.data.frame}.
#' @param return.gdf A logical value indicating whether or not to override defaults (if shape data in
#'     included in the input) and return only metadata as a \code{data.frame}. This parameter is
#'     irrelevant if input is provided without shape data.
#' @param keep.original.ids By default, the ID information is parsed out in the same order as \code{id.factors}
#'     However, if \code{keep.original.ids = TRUE} then the original ID names (encoding metadata) are retained.
#'     The function attempts to do this in a metadata column (named by one of the elements in \code{id.factors})
#'     that has a name like "ID", "specimen", "Sample", etc. For best effect, set the first \code{id.factors}
#'     value as "id". Default is \code{keep.original.ids = FALSE}.
#' @param provenance An object that should be retained for data provenance.
#'
#' @export
#'
#' @examples
#' library(geomorph)
#' data("Bombus.forewings", package = "borealis")
#'
#' names(Bombus.forewings)
#' cat(Bombus.forewings$provenance)
#'
#' Y.gpa <- gpagen(Bombus.forewings$coords)
#'
#' Y.gdf <- id.metadata.to.gdf(
#'   Y.gpa,
#'   id.factors = c("id","species","caste","digitizer"),
#'   provenance = Bombus.forewings$provenance
#' )
#'
#' names(Y.gdf)
#'
#' landmark.plot(Y.gdf$coords)
#' hist(Y.gdf$Csize)
#' with(Y.gdf, boxplot(Csize ~ species))
#' cat(Y.gdf$provenance)
#'

id.metadata.to.gdf <- function (
  A,
  id.factors = "id",
  seperator = "__",
  size.data = NULL,
  return.gdf = TRUE,
  keep.original.ids = FALSE,
  provenance = NULL
)
{
  # Determine the data structure and extract the ID names.
  s <- NULL
  shape.data <- NULL
  if (any(grepl("prcomp",class(A)))) {
    s <- rownames(A$x)
    return.gdf <- FALSE
  } else {
    if (class(A)[1] %in% c("gpagen","list")) {
      s <- dimnames(A$coords)[[3]]
      shape.data <- A$coords
      if (is.null(size.data) & any(grepl("Csize",names(A)))) { size.data <- A$Csize }
      if (is.null(provenance) & any(grepl("provenance",names(A)))) { provenance <- A$provenance }
    } else {
      if ((class(A)[1] == "array") & (length(dim(A)) == 3)) {
        s <- dimnames(A)[[3]]
        shape.data <- A
      } else {
        if (class(A)[1] == "character") {
          s <- A
          return.gdf <- FALSE
        } else {
          stop("Error: Input is not a recognized type. (See the help entry: '?id.metadata.to.gdf'.)")
        }
      }
    }
  }

  # Fail safe
  if (is.null(s)) {
    stop("Error: Input is not a recognized type. (See the help entry: '?id.metadata.to.gdf'.)")
  }

  # Check that the length of id.factors provided matchs the number of divisions in the data

  # Make sure the seperator appears in the ID names!
  if (!any(grepl(seperator,s))) {
    warning(paste("Warning: The seperator",paste0("'",seperator,"'"),"does not appear in the ID information. e.g.",paste0("'",s[1],"'"),"\n"))
  }

  # Extract metadata from the ID string
  metadata <- data.frame(matrix(ncol = length(id.factors)))
  colnames(metadata) <- id.factors
  missing.data <- NULL
  for (i in 1:length(s)) {
    x <- unlist(strsplit(s[i],seperator))
    # Check that there's no right-hand over-run
    if (length(x) > dim(metadata)[2]) {
      metadata <- cbind(metadata, data.frame(matrix(ncol = length(x) - dim(metadata)[2])))
    } else {
      # Check whether any rows fail to fill the columns specified by id.factors
      if (length(x) < dim(metadata)[2]) { missing.data <- c(missing.data, s[i]) }
    }
    metadata[i,] <- x
  }

  # Report on any missing data
  if (!is.null(missing.data)) {
    warning(paste("Warning: The following specimen IDs appear to have missing data: \n",paste0(missing.data, collapse = "\n")))
  }

  # If requested, keep the original IDs from the tps file
  if (keep.original.ids) {
    acceptable.ID.column.names <- c("id","ids","specimen","specimen id","specimen.id","specimen_id","specimen.ids","specimen_ids","sample","sample id","sample.id","sample_id","sample.ids","sample_ids")
    ID.col <- which(tolower(names(metadata)) %in% acceptable.ID.column.names)
    if (length(ID.col)==1) {
      metadata[,ID.col] <- s
    } else {
      warning(paste("Warning: 'keep.original.ids = TRUE' but ID column is ambigous among id.factors (",paste0("'",id.factors,"'",collapse = ", "),"). Try including 'id', among them."))
    }
  }

  # Build the geomorph data.frame
  if (return.gdf & !is.null(shape.data)) {
    gdf <- geomorph.data.frame(metadata,
                               coords = shape.data)

    if (!is.null(size.data)) {
      gdf$Csize <- size.data
    }
    if (!is.null(provenance)) {
      gdf$provenance <- provenance
    }
    gdf[["provenance"]][["gdf.creation"]] <- paste0("## GDF creation\n\nGeomorph data frame created by ",toupper(Sys.getenv("LOGNAME"))," on ",format(Sys.time(), "%A, %d %B %Y, %X"),"\n\n")
    return(gdf)
  } else {
    return(metadata)
  }

} # End of function
